# Story 2.4: Model Integration

**Status:** To Do
**Assignee:** U3 (Danylo Zherzdiev)
**Priority:** Medium
**Sprint:** 2 - Dog Detection

---

## Description

As a developer, I want to integrate the bbox model into the codebase so that it can be used by the pipeline.

---

## Acceptance Criteria

- [ ] BBoxModel class implemented in packages/models/bbox.py
- [ ] Model weights stored in standard location
- [ ] Unit tests written and passing
- [ ] Documentation updated

---

## Tasks

- [ ] Create BBoxModel class following base interface
- [ ] Implement load(), preprocess(), predict(), postprocess()
- [ ] Add configuration dataclass
- [ ] Copy best weights to models/ directory
- [ ] Write unit tests
- [ ] Add docstrings and type hints

---

## Implementation

```python
# packages/models/bbox.py

from dataclasses import dataclass
from pathlib import Path
from typing import Optional

import numpy as np
from ultralytics import YOLO

from .base import BaseModel, ModelConfig

@dataclass
class BBoxConfig(ModelConfig):
    confidence_threshold: float = 0.5
    iou_threshold: float = 0.45
    max_detections: int = 10

@dataclass
class Detection:
    bbox: tuple[int, int, int, int]  # x, y, w, h
    confidence: float
    class_id: int = 0
    class_name: str = "dog"

class BBoxModel(BaseModel):
    def __init__(self, config: BBoxConfig):
        super().__init__(config)
        self.config: BBoxConfig = config
        self.model: Optional[YOLO] = None

    def load(self) -> None:
        self.model = YOLO(self.config.weights_path)

    def preprocess(self, image: np.ndarray) -> np.ndarray:
        # YOLO handles preprocessing internally
        return image

    def predict(self, image: np.ndarray) -> list[Detection]:
        results = self.model(
            image,
            conf=self.config.confidence_threshold,
            iou=self.config.iou_threshold,
            max_det=self.config.max_detections,
            verbose=False
        )[0]

        detections = []
        for box in results.boxes:
            x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
            w, h = x2 - x1, y2 - y1

            detections.append(Detection(
                bbox=(int(x1), int(y1), int(w), int(h)),
                confidence=float(box.conf[0])
            ))

        return detections

    def postprocess(self, detections: list[Detection]) -> list[dict]:
        return [
            {
                "bbox": det.bbox,
                "confidence": det.confidence,
                "class": det.class_name
            }
            for det in detections
        ]
```

---

## Tests

```python
# tests/test_models/test_bbox.py

import pytest
import numpy as np
from packages.models.bbox import BBoxModel, BBoxConfig

@pytest.fixture
def model():
    config = BBoxConfig(weights_path="models/bbox.pt")
    model = BBoxModel(config)
    model.load()
    return model

def test_predict_returns_list(model):
    image = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
    detections = model.predict(image)
    assert isinstance(detections, list)

def test_detection_has_bbox(model):
    image = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
    detections = model.predict(image)
    if detections:
        assert hasattr(detections[0], 'bbox')
        assert len(detections[0].bbox) == 4
```

---

## Output

- `packages/models/bbox.py`
- `packages/models/base.py` (if not exists)
- `tests/test_models/test_bbox.py`
- `models/bbox.pt` (weights file)
